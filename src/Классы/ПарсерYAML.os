#Использовать logos

Перем ТокеныСтроки;
Перем СтрокаYaml;
Перем Лог;

Функция ПрочитатьYAML(Знач ВходящаяСтрока) Экспорт

	ТокеныСтроки = ТокеныYAML.ПрочитатьТокены(ВходящаяСтрока);
	
	Для каждого Переменная Из ТокеныСтроки Цикл
		Лог.Отладка("токен %1 значение: %2", Переменная.Тип, Переменная.Значение);
	КонецЦикла;
	
	СтрокаYaml = ВходящаяСтрока;
	Лог.Отладка("Количество токенов: %1", ТокеныСтроки.Количество());
	Возврат Прочитать();

КонецФункции

Функция ТекущийТокен() //peek
	
	Возврат ТокеныСтроки[0];
	
КонецФункции

Функция ПолучитьПервый() //advance / shift

	Результат = ТекущийТокен();
	УбратьИзОчереди();
	Возврат Результат;
КонецФункции

Функция ПолучитьЗначениеПервого() //advanceValue
	Результат = ПолучитьПервый();
	Возврат Результат.Значение[1];
КонецФункции

Функция accept(ТипТокена) //accept
	Если ТекущийТипТокена(ТипТокена) Тогда
		Возврат ПолучитьПервый();
	КонецЕсли;
	Возврат Неопределено;
КонецФункции


Процедура expect(ТипТокена, ДопСообщение)
	
	Если НЕ accept(ТипТокена) = Неопределено Тогда
		Возврат;
	КонецЕсли;

	ВызватьИсключение ДопСообщение;

КонецПроцедуры

Процедура УбратьИзОчереди()
	
	ТокеныСтроки.Удалить(0);

КонецПроцедуры

Функция ТекущийТипТокена(ТипТокена) //peekType
		Возврат ТекущийТокен().Тип = ТипТокена;
КонецФункции

Процедура ПропуститьПробелы() //ignoreSpace

	Пока ТекущийТипТокена("space") Цикл
			ПолучитьПервый();
	КонецЦикла;

КонецПроцедуры

Процедура ignoreWhitespace() //ignoreWhitespace

	Пока ТекущийТипТокена("space")
			ИЛИ ТекущийТипТокена("indent")
			ИЛИ ТекущийТипТокена("dedent") Цикл
			ПолучитьПервый();
	КонецЦикла;

КонецПроцедуры


Функция Прочитать()
	
	Тип = ТекущийТокен().Тип;
	Лог.Отладка("Прочитать > тип токена: %1", Тип);
	Если Тип = "doc" Тогда
		Возврат ПрочитатьДокумент();
	ИначеЕсли Тип = "-" Тогда
		Возврат ПрочитатьСписок(); 
	ИначеЕсли Тип = "{" Тогда
		Возврат parseInlineHash(); 
	ИначеЕсли Тип = "[" Тогда
		Возврат parseInlineList(); 
	ИначеЕсли Тип = "id" Тогда
		Возврат parseHash(); 
	ИначеЕсли Тип = "string" Тогда
		Возврат ПолучитьЗначениеПервого(); 
	ИначеЕсли Тип = "timestamp" Тогда
		Возврат parseTimestamp(); 
	ИначеЕсли Тип = "float" Тогда
		Возврат Число(ПолучитьЗначениеПервого()); 
	ИначеЕсли Тип = "int" Тогда
		Возврат Число(ПолучитьЗначениеПервого()); 
	ИначеЕсли Тип = "true" Тогда
		ПолучитьЗначениеПервого(); 
		Возврат Истина
	ИначеЕсли Тип = "false" Тогда
		ПолучитьЗначениеПервого(); 
		Возврат Ложь
	ИначеЕсли Тип = "null" Тогда
		ПолучитьЗначениеПервого(); 
		Возврат Неопределено
	КонецЕсли;
	
КонецФункции


//'---'? indent expr dedent
//
Функция ПрочитатьДокумент()
	
	accept("doc");
	expect("indent", "expected indent after document");
	Значение = Прочитать();
	expect("dedent", "document not properly dedented");
	Возврат Значение;

КонецФункции


//   ( id ':' - expr -
//   | id ':' - indent expr dedent
//   )+
Функция parseHash()
	
	hash = Новый Соответствие;
	Индентификатор = ТекущийТокен().Значение[1];

	Пока ТекущийТипТокена("id") И
		НЕ ПолучитьПервый() = Неопределено Цикл
		Лог.Отладка("В начале Тип токена: %1", ТекущийТокен().Тип);
		
		expect(":", "expected semi-colon after id");
		
		ПропуститьПробелы();
		
		Если НЕ accept("indent") = Неопределено Тогда
			hash[Индентификатор] = Прочитать();
			expect("dedent", "hash not properly dedented");
		Иначе
			hash[Индентификатор] = Прочитать();
		КонецЕсли;

		Лог.Отладка("Индентификатор: %1 значение: %2", Индентификатор, hash[Индентификатор]);
		

		ПропуститьПробелы();
		
		Лог.Отладка("Тип токена: %1", ТекущийТокен().Тип);
		Индентификатор = ТекущийТокен().Значение[1];
		//ПолучитьЗначениеПервого();
			
	КонецЦикла;

	return hash

КонецФункции

// /**
//  * '{' (- ','? ws id ':' - expr ws)* '}'
//  */
Функция parseInlineHash()
// 	Parser.prototype.parseInlineHash = function() {
// 	var hash = {}, id, i = 0
// 	this.accept('{')
// 	while (!this.accept('}')) {
// 		this.ignoreSpace()
// 		if (i) this.expect(',', 'expected comma')
// 		this.ignoreWhitespace()
// 		if (this.peekType('id') && (id = this.advanceValue())) {
// 			this.expect(':', 'expected semi-colon after id')
// 			this.ignoreSpace()
// 			hash[id] = this.parse()
// 			this.ignoreWhitespace()
// 		}
// 		++i
// 	}
// 	return hash
// }
КонецФункции

// /**
//  *  ( '-' - expr -
//  *  | '-' - indent expr dedent
//  *  )+
//  */
Функция ПрочитатьСписок()
	
	Список = новый Массив;

	Пока accept("-") Цикл
		ПропуститьПробелы();

		Если accept("indent") Тогда
			
			Список.Добавить(Прочитать());
			expect("dedent", "list item not properly dedented");
		Иначе
			Список.Добавить(Прочитать());
		КонецЕсли;
		ПропуститьПробелы();

	КонецЦикла;

	return Список;

КонецФункции

// /**
//  * '[' (- ','? - expr -)* ']'
//  */
Функция parseInlineList()
	
	Список = новый Массив;
	accept("[");
	Первый = Истина;
	Пока accept("]") Цикл
		ПропуститьПробелы();
		Если Не Первый Тогда
			expect(",", "expected comma");
			Первый = Ложь;
		КонецЕсли;
		ПропуститьПробелы();
		Список.Добавить(Прочитать());
		ПропуститьПробелы();

	КонецЦикла;

	Возврат Список;
КонецФункции

// /**
//  * yyyy-mm-dd hh:mm:ss
//  *
//  * For full format: http://yaml.org/type/timestamp.html
//  */
Функция parseTimestamp()
	// var token = this.advance()[1]
	// var date = new Date
	// var year = token[2]
	// 	, month = token[3]
	// 	, day = token[4]
	// 	, hour = token[5] || 0 
	// 	, min = token[6] || 0
	// 	, sec = token[7] || 0

	// date.setUTCFullYear(year, month-1, day)
	// date.setUTCHours(hour)
	// date.setUTCMinutes(min)
	// date.setUTCSeconds(sec)
	// date.setUTCMilliseconds(0)
	// return date
	Возврат Дата(01,01,01);
КонецФункции

Лог = Логирование.ПолучитьЛог("oscript.lib.yaml");
Лог.УстановитьУровень(УровниЛога.Отладка);